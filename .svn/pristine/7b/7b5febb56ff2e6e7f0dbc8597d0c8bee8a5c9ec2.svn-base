package com.yeahmobi.yscheduler.agentframework.agent.task.shell;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.exec.CommandLine;
import org.apache.commons.exec.DefaultExecutor;
import org.apache.commons.exec.ExecuteException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.http.Header;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import com.yeahmobi.yscheduler.agentframework.agent.task.BaseTaskExecutor;
import com.yeahmobi.yscheduler.agentframework.agent.task.FileBasedTaskTransactionManager;
import com.yeahmobi.yscheduler.agentframework.agent.task.TaskTransaction;
import com.yeahmobi.yscheduler.agentframework.utils.HttpClientUtil;

/**
 * @author Leo.Liang
 */
public class ShellTaskExecutor extends BaseTaskExecutor<ShellAgentTask> {

    private static final Logger             LOGGER               = LoggerFactory.getLogger(ShellTaskExecutor.class);

    private static final String             FILESERVER_NAMESPACE = "task";

    private static final long               CHECK_INTERVAL       = 1;

    private String                          baseDir;
    private String                          shellDir;
    private String                          attachmentRootDir;

    private FileBasedTaskTransactionManager taskTransactionManager;

    public void setTaskTransactionManager(FileBasedTaskTransactionManager transactionManager) {
        this.taskTransactionManager = transactionManager;
    }

    public void init() throws IOException {
        // 复制shell到 baseDir/shell
        this.baseDir = this.taskTransactionManager.getBaseDir();
        this.shellDir = this.baseDir + "/shell";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        Resource[] resources = resolver.getResources(getShellPathPattern());

        File shellDirFile = new File(this.shellDir);
        FileUtils.forceMkdir(shellDirFile);

        for (Resource resource : resources) {
            FileUtils.copyInputStreamToFile(resource.getInputStream(), new File(shellDirFile, resource.getFilename()));
        }

        File attachmentDirFile = new File(this.attachmentRootDir);
        FileUtils.forceMkdir(attachmentDirFile);
    }

    private String getShellPathPattern() {
        return "classpath*:/" + ShellTaskExecutor.class.getPackage().getName().replace('.', '/') + "/*.sh";
    }

    public Integer execute(TaskTransaction<ShellAgentTask> taskTransaction) throws ExecuteException, IOException,
                                                                           InterruptedException {
        Integer exitCode = null;

        long txId = taskTransaction.getId();

        ShellAgentTask task = taskTransaction.getTask();

        boolean everStarted = everStarted(txId, task.getEventType());
        // 从未执行过，则run
        if (!everStarted) {
            String command = task.getCommand();
            // 下载附件
            if (hasAttachment(task)) {
                downloadAttachment(task);
                // 有附件，执行时，shell需要先进入附件目录
                command = "cd " + getAttachmentDir(task) + ";" + command;
            }

            // 执行shell
            runShell(taskTransaction, txId, command, task.getEventType());
        }

        // 论询pid和exitCode
        while (checkRunningByPid(txId, task.getEventType())) {
            TimeUnit.SECONDS.sleep(CHECK_INTERVAL);
        }

        exitCode = getExitCode(txId, task.getEventType());

        return exitCode;

    }

    private void downloadAttachment(ShellAgentTask task) throws FileNotFoundException, IOException {
        Long attachmentVersion = task.getAttachmentVersion();
        // 确认目录是否存在，不存在，或存在版本小，则下载
        boolean needDownload = true;
        File taskDir = new File(getAttachmentParentDir(task));
        File attachmentDir = new File(getAttachmentDir(task));
        FileUtils.forceMkdir(attachmentDir);
        File versionFile = null;
        if (taskDir.exists()) {
            versionFile = new File(taskDir, ".version");
            if (versionFile.exists()) {
                String versionString = IOUtils.toString(new FileInputStream(versionFile));
                if (StringUtils.isNotBlank(versionString)) {
                    Long existsAttachmentVersion = Long.parseLong(versionString);
                    if (existsAttachmentVersion >= attachmentVersion) {
                        needDownload = false;
                    }
                }
            }
        }
        if (needDownload) {
            // 直接下载
            String uri = task.getAttachmentServerUri();
            Map<String, String> params = new HashMap<String, String>();
            params.put("namespace", FILESERVER_NAMESPACE);
            params.put("key", task.getTaskName());
            params.put("version", String.valueOf(attachmentVersion));

            CloseableHttpResponse response = HttpClientUtil.getResponse(uri, params);
            try {
                Header filenameHeader = response.getFirstHeader("filename");
                String filename = filenameHeader != null ? filenameHeader.getValue() : "unknown";
                // 通过filename判断是zip还是shell
                boolean isZip = false;
                if (StringUtils.endsWithIgnoreCase(filename, ".zip")) {
                    isZip = true;
                }

                // 下载附件（并解压到指定目录）
                InputStream content = response.getEntity().getContent();
                if (isZip) {
                    unzip(attachmentDir, content);
                } else {
                    File dstFile = new File(attachmentDir, filename);
                    IOUtils.copyLarge(content, new FileOutputStream(dstFile));
                }

                // 更新.version文件
                OutputStream output = new FileOutputStream(new File(taskDir, ".version"));
                IOUtils.write(String.valueOf(attachmentVersion), output);

            } finally {
                response.close();
            }

        } else {
            // 有带version带不需要下载，也touch一下version，表示附件是有被访问的（因为后续会定期会清理长时间未访问的附件）
            versionFile.setLastModified(System.currentTimeMillis());
        }
    }

    private boolean hasAttachment(ShellAgentTask task) {
        Long attachmentVersion = task.getAttachmentVersion();
        return attachmentVersion == null;
    }

    private String getAttachmentParentDir(ShellAgentTask task) {
        return this.attachmentRootDir + "/" + task.getTaskName();
    }

    private String getAttachmentDir(ShellAgentTask task) {
        return this.attachmentRootDir + "/" + task.getTaskName() + "/attachment";
    }

    @SuppressWarnings("resource")
    private void unzip(File attachmentDir, InputStream content) throws IOException, FileNotFoundException {
        ZipArchiveInputStream zipInput = new ZipArchiveInputStream(content);
        ArchiveEntry entry = zipInput.getNextEntry();
        while (entry != null) {
            File dstFile = new File(attachmentDir, entry.getName());
            if (entry.isDirectory()) {
                FileUtils.forceMkdir(dstFile);
            } else {
                byte[] bytes = new byte[(int) entry.getSize()];
                int readSizes = 0;
                while ((readSizes < bytes.length) && (zipInput.available() > 0)) {
                    int n = zipInput.read(bytes, readSizes, bytes.length - readSizes);
                    readSizes += n;
                }
                OutputStream output = new FileOutputStream(dstFile);
                IOUtils.write(bytes, output);
            }
            LOGGER.info("download and unzip: " + entry.getName() + ":" + entry.getSize());
            entry = zipInput.getNextEntry();
        }
    }

    public void cancel(TaskTransaction taskTransaction) throws ExecuteException, IOException {
        long txId = taskTransaction.getId();
        String eventType = taskTransaction.getMeta().getEventType();

        CommandLine cmdLine = new CommandLine("bash");
        cmdLine.addArgument(this.baseDir + "/shell/cancel.sh");
        cmdLine.addArgument(this.baseDir);
        cmdLine.addArgument(String.valueOf(txId));
        cmdLine.addArgument(eventType);
        DefaultExecutor executor = new DefaultExecutor();
        executor.setExitValues(new int[] { 0 });

        executor.execute(cmdLine);
    }

    private void runShell(final TaskTransaction taskTransaction, long txId, String command, String eventType)
                                                                                                             throws ExecuteException,
                                                                                                             IOException {
        CommandLine cmdLine = new CommandLine("bash");
        cmdLine.addArgument(this.baseDir + "/shell/run.sh");
        cmdLine.addArgument(this.baseDir);
        cmdLine.addArgument(String.valueOf(txId));
        cmdLine.addArgument(eventType);
        cmdLine.addArgument(command, false);
        DefaultExecutor executor = new DefaultExecutor();
        executor.setExitValues(null);

        executor.execute(cmdLine);
    }

    private boolean everStarted(long txId, String eventType) {
        // 是否有pid
        File file = new File(this.baseDir + "/" + txId + "/" + eventType + "/pid");
        return file.exists();
    }

    private Integer getExitCode(long txId, String eventType) {
        File file = new File(this.baseDir + "/" + txId + "/" + eventType + "/exitcode");
        if (file.exists()) {
            try {
                String exitCodeStr = StringUtils.trim(IOUtils.toString(new FileInputStream(file)));
                return Integer.parseInt(exitCodeStr);
            } catch (Exception e) {
                return null;
            }
        }
        return null;
    }

    private boolean checkRunningByPid(long txId, String eventType) throws ExecuteException, IOException {
        CommandLine cmdLine = new CommandLine("bash");
        cmdLine.addArgument(this.baseDir + "/shell/check.sh");
        cmdLine.addArgument(this.baseDir);
        cmdLine.addArgument(String.valueOf(txId));
        cmdLine.addArgument(eventType);
        DefaultExecutor executor = new DefaultExecutor();
        executor.setExitValues(null);

        int exitCode = executor.execute(cmdLine);

        return exitCode == 1;
    }

    public void setAttachmentRootDir(String attachmentDir) {
        this.attachmentRootDir = attachmentDir;
    }

    @SuppressWarnings("resource")
    public static void main(String[] args) throws Exception {
        InputStream content = new FileInputStream("/home/atell/download/bootstrap-switch-master.zip");
        ZipArchiveInputStream zipInput = new ZipArchiveInputStream(content);
        ArchiveEntry entry = zipInput.getNextEntry();
        while (entry != null) {
            File dstFile = new File("/tmp", entry.getName());
            if (entry.isDirectory()) {
                FileUtils.forceMkdir(dstFile);
            } else {
                byte[] bytes = new byte[(int) entry.getSize()];
                int readSizes = 0;
                while ((readSizes < bytes.length) && (zipInput.available() > 0)) {
                    int n = zipInput.read(bytes, readSizes, bytes.length - readSizes);
                    readSizes += n;
                }
                OutputStream output = new FileOutputStream(dstFile);
                IOUtils.write(bytes, output);
            }
            System.out.println(entry.getName() + ":" + entry.getSize());
            entry = zipInput.getNextEntry();
        }
    }
}
