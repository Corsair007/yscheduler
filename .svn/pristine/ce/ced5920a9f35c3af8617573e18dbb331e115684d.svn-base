package com.yeahmobi.yscheduler.scheduler;

import java.util.Date;
import java.util.List;
import java.util.TimeZone;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.LockSupport;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DuplicateKeyException;
import org.springframework.scheduling.support.CronSequenceGenerator;
import org.springframework.stereotype.Service;

import com.yeahmobi.yscheduler.executor.TaskInstanceExecutor;
import com.yeahmobi.yscheduler.model.Task;
import com.yeahmobi.yscheduler.model.TaskInstance;
import com.yeahmobi.yscheduler.model.Workflow;
import com.yeahmobi.yscheduler.model.WorkflowInstance;
import com.yeahmobi.yscheduler.model.service.ScheduleProgressService;
import com.yeahmobi.yscheduler.model.service.TaskInstanceService;
import com.yeahmobi.yscheduler.model.service.TaskService;
import com.yeahmobi.yscheduler.model.service.WorkflowInstanceService;
import com.yeahmobi.yscheduler.model.service.WorkflowService;
import com.yeahmobi.yscheduler.model.type.TaskInstanceStatus;
import com.yeahmobi.yscheduler.model.type.TaskStatus;
import com.yeahmobi.yscheduler.model.type.WorkflowInstanceStatus;
import com.yeahmobi.yscheduler.model.type.WorkflowStatus;
import com.yeahmobi.yscheduler.workflow.WorkflowExecutor;

@Service
public class DefaultSchedulerExecutor implements SchedulerExecutor {

    private static final Logger     LOGGER   = LoggerFactory.getLogger(DefaultSchedulerExecutor.class);

    private static final long       INTERVAL = 10 * 1000;

    private static final TimeZone   TIMEZONE = TimeZone.getTimeZone("GMT+8:00");

    private AtomicBoolean           closed   = new AtomicBoolean(false);

    private ScheduleThread          controllerThread;

    private long                    currentScheduleTime;

    @Autowired
    private ScheduleProgressService scheduleProgressService;

    @Autowired
    private WorkflowExecutor        workflowExecutor;

    @Autowired
    private WorkflowService         workflowService;

    @Autowired
    private WorkflowInstanceService workflowInstanceService;

    @Autowired
    private TaskInstanceExecutor    taskInstanceExecutor;

    @Autowired
    private TaskService             taskService;

    @Autowired
    private TaskInstanceService     taskInstanceService;

    @PostConstruct
    public void init() {
        boolean recover = Boolean.parseBoolean(System.getProperty("ysheduler.schedule.recover", "true"));

        if (recover) {
            Long scheduleTime = this.scheduleProgressService.getCurrentScheduleTime();
            this.currentScheduleTime = scheduleTime != null ? scheduleTime : System.currentTimeMillis();
        } else {
            this.currentScheduleTime = System.currentTimeMillis();
        }

        // 启动后台执行线程
        this.controllerThread = new ScheduleThread();
        this.controllerThread.setName("scheduler");
        this.controllerThread.setDaemon(true);
        this.controllerThread.start();
    }

    @PreDestroy
    public void close() {
        if (this.closed.compareAndSet(false, true)) {
            this.controllerThread.interrupt();
        }
    }

    private class ScheduleThread extends Thread {

        @Override
        public void run() {

            while (!DefaultSchedulerExecutor.this.closed.get()) {
                try {
                    List<Workflow> workflowList = DefaultSchedulerExecutor.this.workflowService.listAll(WorkflowStatus.OPEN);
                    List<Task> taskList = DefaultSchedulerExecutor.this.taskService.listAll(TaskStatus.OPEN);
                    Date curDate = new Date(DefaultSchedulerExecutor.this.currentScheduleTime);

                    if (workflowList != null) {
                        // 当前调度时间

                        for (Workflow workflow : workflowList) {
                            CronSequenceGenerator generator = new CronSequenceGenerator(workflow.getCrontab(), TIMEZONE);
                            // 预期调度时间
                            Date scheduleTime = generator.next(curDate);

                            // 如果预期调度时间-当前调度时间<=INTERVAL,则触发调度
                            if ((scheduleTime.getTime() - curDate.getTime()) <= INTERVAL) {
                                WorkflowInstance instance = new WorkflowInstance();
                                instance.setScheduleTime(scheduleTime);
                                instance.setStatus(WorkflowInstanceStatus.INITED);
                                instance.setWorkflowId(workflow.getId());
                                try {
                                    DefaultSchedulerExecutor.this.workflowInstanceService.save(instance);
                                    DefaultSchedulerExecutor.this.workflowExecutor.submit(instance);
                                } catch (DuplicateKeyException e) {
                                    // ignored
                                } catch (Exception e) {
                                    LOGGER.error(e.getMessage(), e);
                                }
                            }
                        }
                    }

                    if (taskList != null) {
                        for (Task task : taskList) {
                            CronSequenceGenerator generator = new CronSequenceGenerator(task.getCrontab(), TIMEZONE);
                            // 预期调度时间
                            Date scheduleTime = generator.next(curDate);

                            // 如果预期调度时间-当前调度时间<=INTERVAL,则触发调度
                            if ((scheduleTime.getTime() - curDate.getTime()) <= INTERVAL) {
                                TaskInstance instance = new TaskInstance();
                                instance.setTaskId(task.getId());
                                instance.setStartTime(scheduleTime);
                                instance.setStatus(TaskInstanceStatus.READY);
                                try {
                                    DefaultSchedulerExecutor.this.taskInstanceService.save(instance);
                                    DefaultSchedulerExecutor.this.taskInstanceExecutor.submit(instance);
                                } catch (DuplicateKeyException e) {
                                    // ignored
                                } catch (Exception e) {
                                    LOGGER.error(e.getMessage(), e);
                                }
                            }
                        }
                    }

                    // 每隔 INTERVAL 时间调度一次
                    DefaultSchedulerExecutor.this.currentScheduleTime += INTERVAL;
                    // 持久化进度
                    try {
                        DefaultSchedulerExecutor.this.scheduleProgressService.saveCurrentScheduleTime(DefaultSchedulerExecutor.this.currentScheduleTime);
                    } catch (Exception e) {
                        LOGGER.error("Error when save the currentScheduleTime", e);
                    }

                    try {
                        if (System.currentTimeMillis() < DefaultSchedulerExecutor.this.currentScheduleTime) {
                            parkUntil(DefaultSchedulerExecutor.this.currentScheduleTime);
                        } else {
                            LockSupport.parkNanos(1000);
                        }
                    } catch (InterruptedException e) {
                        // ignored. maybe will close.
                    }
                } catch (Throwable e) {
                    // TODO
                }
            }
        }
    }

    private void parkUntil(long absTime) throws InterruptedException {
        while (System.currentTimeMillis() < absTime) {
            LockSupport.parkUntil(absTime);
            if (Thread.currentThread().isInterrupted()) {
                throw new InterruptedException();
            }
        }
    }

}
