package com.yeahmobi.yscheduler.agentframework.agent.event.task;

import java.io.IOException;
import java.util.Map;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.apache.commons.lang.BooleanUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.yeahmobi.yscheduler.agentframework.agent.task.TaskTransaction;
import com.yeahmobi.yscheduler.agentframework.utils.LogUtil;

public abstract class AbstractCalloutTaskExecutor extends AbstractAsyncTaskExecutor {

    private static final Logger  LOGGER               = LoggerFactory.getLogger(AbstractCalloutTaskExecutor.class);

    private static final int     INTERVAL             = 1;

    // 等待6小时，即6*60*60s
    private static final long    MAX_WAIT_COUNT       = 21600;

    // 超时的返回值
    private static final Integer RETURN_VALUE_TIMEOUT = -2;

    private volatile boolean     cancel               = false;
    private TaskTransaction      taskTransaction;

    public void execute(TaskTransaction taskTransaction) {
        this.taskTransaction = taskTransaction;
        try {
            // callout
            callout(taskTransaction, this.getParams());

            if (needCallback(this.getParams())) {
                // add futureTask to Map
                FutureTask<Void> task = new FutureTask<Void>(new Runnable() {

                    public void run() {
                    }
                }, null);

                holder.put(taskTransaction.getId(), new Pair(taskTransaction, task));

                // wait for callback
                long waitCount = 0;
                while (!this.cancel) {
                    try {
                        task.get(INTERVAL, TimeUnit.SECONDS);
                        break;

                        // 由callback设置taskTransaction成功与否
                        // taskTransaction.endWithSuccess(0);
                    } catch (TimeoutException e) {
                        // 30秒打一次log
                        if ((waitCount++ % 30) == 0) {
                            LogUtil.info(taskTransaction, "Waiting for callback count: " + waitCount);
                        }
                        // 等待超过一定次数则自动失败
                        if (waitCount > MAX_WAIT_COUNT) {// 等待超过阈值后，直接fail
                            LogUtil.info(taskTransaction, "Wait times reach limit and it will auto failed, count: "
                                                          + waitCount);
                            taskTransaction.endWithFail(RETURN_VALUE_TIMEOUT);
                            break;
                        }
                    } catch (Throwable e) {
                        LogUtil.error(taskTransaction, e.getMessage(), e);
                        taskTransaction.endWithFail(null);
                        break;
                    }
                }

            } else {
                // 不需要callback，则再callout成功后顺利结束
                taskTransaction.endWithSuccess(0);
            }

        } catch (Exception e1) {
            try {
                LOGGER.error(e1.getMessage(), e1);
                LogUtil.error(taskTransaction, e1.getMessage(), e1);
            } catch (IOException e) {
                LOGGER.error(e.getMessage(), e);
            }
            taskTransaction.endWithFail(null);
        }
    }

    public void cancel() {
        try {
            cancel(this.taskTransaction, this.getParams());
        } catch (Exception e) {
            try {
                LogUtil.error(this.taskTransaction, "Error when cancelling", e);
            } catch (IOException e1) {
                LOGGER.error(e1.getMessage(), e1);
            }
        }
        this.cancel = true;
    }

    private boolean needCallback(Map<String, String> params) {
        return BooleanUtils.toBoolean(params.get("needCallback"));
    }

    protected abstract void callout(TaskTransaction taskTransaction, Map<String, String> params) throws Exception;

    /**
     * 执行cancel操作，方法正确退出表示cancel成功，否则抛出异常
     */
    protected abstract void cancel(TaskTransaction taskTransaction, Map<String, String> params) throws Exception;

}
