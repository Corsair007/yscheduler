package com.yeahmobi.yscheduler.agentframework.agent.task.shell;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.commons.compress.archivers.ArchiveEntry;
import org.apache.commons.compress.archivers.zip.ZipArchiveInputStream;
import org.apache.commons.exec.CommandLine;
import org.apache.commons.exec.DefaultExecutor;
import org.apache.commons.exec.ExecuteException;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.http.Header;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.springframework.core.io.Resource;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;

import com.yeahmobi.yscheduler.agentframework.agent.task.BaseTaskExecutor;
import com.yeahmobi.yscheduler.agentframework.agent.task.FileBasedTaskTransactionManager;
import com.yeahmobi.yscheduler.agentframework.agent.task.TaskTransaction;
import com.yeahmobi.yscheduler.agentframework.lock.TaskLocks;
import com.yeahmobi.yscheduler.agentframework.utils.HttpClientUtil;

/**
 * @author Leo.Liang
 */
public class ShellTaskExecutor extends BaseTaskExecutor<ShellAgentTask> {

    // private static final Logger LOGGER = LoggerFactory.getLogger(ShellTaskExecutor.class);

    private static final String             SHELL_SUFFIX         = ".sh";

    private static final String             FILESERVER_NAMESPACE = "task";

    private static final long               CHECK_INTERVAL       = 1;

    private String                          baseDir;
    private String                          shellDir;
    private String                          attachmentRootDir;

    private FileBasedTaskTransactionManager taskTransactionManager;

    public void setTaskTransactionManager(FileBasedTaskTransactionManager transactionManager) {
        this.taskTransactionManager = transactionManager;
    }

    public void init() throws IOException {
        // 复制shell到 baseDir/shell
        this.baseDir = this.taskTransactionManager.getBaseDir();
        this.shellDir = this.baseDir + "/shell";

        PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();
        Resource[] resources = resolver.getResources(getShellPathPattern());

        File shellDirFile = new File(this.shellDir);
        FileUtils.forceMkdir(shellDirFile);

        for (Resource resource : resources) {
            InputStream stream = resource.getInputStream();
            try {
                FileUtils.copyInputStreamToFile(stream, new File(shellDirFile, resource.getFilename()));
            } finally {
                IOUtils.closeQuietly(stream);
            }
        }

        File attachmentDirFile = new File(this.attachmentRootDir);
        FileUtils.forceMkdir(attachmentDirFile);
    }

    private String getShellPathPattern() {
        return "classpath*:/" + ShellTaskExecutor.class.getPackage().getName().replace('.', '/') + "/*.sh";
    }

    public Integer execute(TaskTransaction<ShellAgentTask> taskTransaction) throws ExecuteException, IOException,
                                                                           InterruptedException {
        Integer exitCode = null;

        long txId = taskTransaction.getId();

        taskTransaction.info("Shell task started ( transaction is " + txId + " )");

        ShellAgentTask task = taskTransaction.getTask();

        boolean everStarted = everStarted(txId, task.getEventType());
        // 从未执行过，则run
        if (!everStarted) {
            String command = task.getCommand();
            // 下载附件
            String attachmentDir = null;
            if (hasAttachment(task)) {
                taskTransaction.info("Attachment version: " + task.getAttachmentVersion());

                downloadAttachment(task, taskTransaction);
                // 有附件，执行时，shell需要先进入附件目录
                // “进去附件的操作”改在run.sh中，因为bash -c "多指令"时pid不准确，cancel有影响；
                // command = "cd " + getAttachmentDir(task) + ";" + command;
                attachmentDir = getAttachmentDir(task);
            }

            // 执行shell
            runShell(taskTransaction, txId, command, task.getEventType(), attachmentDir);
        }

        // 论询pid和exitCode
        while (checkRunningByPid(txId, task.getEventType())) {
            TimeUnit.SECONDS.sleep(CHECK_INTERVAL);
        }

        exitCode = getExitCode(txId, task.getEventType());

        return exitCode;

    }

    private void downloadAttachment(ShellAgentTask task, TaskTransaction<ShellAgentTask> taskTransaction)
                                                                                                         throws FileNotFoundException,
                                                                                                         IOException {
        Long attachmentVersion = task.getAttachmentVersion();
        // 确认目录是否存在，不存在，或存在版本小，则下载
        boolean needDownload = true;
        File taskDir = new File(getAttachmentParentDir(task));
        File attachmentDir = new File(getAttachmentDir(task));
        FileUtils.forceMkdir(attachmentDir);
        File versionFile = null;
        if (taskDir.exists()) {
            versionFile = new File(taskDir, ".version");
            if (versionFile.exists()) {
                FileInputStream fileInputStream = new FileInputStream(versionFile);
                try {
                    String versionString = IOUtils.toString(fileInputStream);
                    if (StringUtils.isNotBlank(versionString)) {
                        Long existsAttachmentVersion = Long.parseLong(versionString);
                        taskTransaction.info("Exists Attachment version: " + existsAttachmentVersion);
                        if (existsAttachmentVersion >= attachmentVersion) {
                            needDownload = false;
                        }
                    }
                } finally {
                    IOUtils.closeQuietly(fileInputStream);
                }
            }
        }
        if (needDownload) {

            // 相同task，要串行下载，才能保护数据正确
            ReentrantLock lock = TaskLocks.getLock(task.getTaskName());
            try {
                lock.lock();

                File tempAttachmentDir = new File(getTempAttachmentDir(task));
                FileUtils.forceMkdir(tempAttachmentDir);
                // 直接下载
                String uri = task.getAttachmentServerUri();
                Map<String, String> params = new HashMap<String, String>();
                params.put("nameSpace", FILESERVER_NAMESPACE);
                params.put("key", task.getTaskName());
                params.put("version", String.valueOf(attachmentVersion));

                taskTransaction.info(String.format("Start to download attachment from %s", uri));
                CloseableHttpResponse response = HttpClientUtil.getResponse(uri, params);
                try {
                    Header filenameHeader = response.getFirstHeader("filename");
                    String filename = filenameHeader != null ? filenameHeader.getValue() : "unknown";

                    taskTransaction.info(String.format("Attachment filename is %s", filename));

                    // 通过filename判断是zip还是shell
                    boolean isZip = false;
                    if (StringUtils.endsWithIgnoreCase(filename, ".zip")) {
                        isZip = true;
                    }

                    // 下载附件（并解压到指定目录）
                    InputStream content = response.getEntity().getContent();
                    if (isZip) {
                        unzip(tempAttachmentDir, content, taskTransaction);
                    } else {
                        File dstFile = new File(tempAttachmentDir, filename);
                        FileOutputStream dstFileOutput = new FileOutputStream(dstFile);
                        try {
                            IOUtils.copyLarge(content, dstFileOutput);
                        } finally {
                            IOUtils.closeQuietly(dstFileOutput);
                        }
                        makeExecutable(dstFile);
                    }
                    taskTransaction.info("Attachment downloaded");

                    // mv tempAttachment to Attachment
                    FileUtils.deleteDirectory(attachmentDir);
                    FileUtils.moveDirectory(tempAttachmentDir, attachmentDir);

                    // 更新.version文件
                    OutputStream output = new FileOutputStream(new File(taskDir, ".version"));
                    try {
                        IOUtils.write(String.valueOf(attachmentVersion), output);
                    } finally {
                        IOUtils.closeQuietly(output);
                    }
                    taskTransaction.info(String.format("Attachment version updated to %s", attachmentVersion));

                } finally {
                    response.close();
                    FileUtils.deleteDirectory(tempAttachmentDir);// ensure delete temp
                }
            } finally {
                lock.unlock();
            }

        } else {
            taskTransaction.info("Need not download attachment.");
            // 有带version带不需要下载，也touch一下version，表示附件是有被访问的（因为后续会定期会清理长时间未访问的附件）
            versionFile.setLastModified(System.currentTimeMillis());
        }
    }

    private void makeExecutable(File dstFile) {
        // 如果是shell，则设置成可执行
        if (StringUtils.endsWithIgnoreCase(dstFile.getName(), SHELL_SUFFIX)) {
            dstFile.setExecutable(true, false);
        }
    }

    private boolean hasAttachment(ShellAgentTask task) {
        Long attachmentVersion = task.getAttachmentVersion();
        return attachmentVersion != null;
    }

    private String getAttachmentParentDir(ShellAgentTask task) {
        return this.attachmentRootDir + "/" + task.getTaskName();
    }

    private String getAttachmentDir(ShellAgentTask task) {
        return this.attachmentRootDir + "/" + task.getTaskName() + "/attachment";
    }

    private String getTempAttachmentDir(ShellAgentTask task) {
        return this.attachmentRootDir + "/" + task.getTaskName() + "/temp-" + System.currentTimeMillis();
    }

    private void unzip(File attachmentDir, InputStream content, TaskTransaction<ShellAgentTask> taskTransaction)
                                                                                                                throws IOException,
                                                                                                                FileNotFoundException {
        ZipArchiveInputStream zipInput = new ZipArchiveInputStream(content);
        try {
            ArchiveEntry entry;
            while ((entry = zipInput.getNextEntry()) != null) {
                File dstFile = new File(attachmentDir, entry.getName());
                if (entry.isDirectory()) {
                    FileUtils.forceMkdir(dstFile);
                } else {
                    taskTransaction.info(String.format("Downloading(unzip) %s (size:%sbytes)", entry.getName(),
                                                       entry.getSize()));
                    byte[] bytes = new byte[(int) entry.getSize()];
                    int readSizes = 0;
                    while (readSizes < bytes.length) {
                        int n = zipInput.read(bytes, readSizes, bytes.length - readSizes);
                        if (n == -1) {
                            break;
                        } else {
                            readSizes += n;
                        }
                    }
                    OutputStream output = new FileOutputStream(dstFile);
                    try {
                        IOUtils.write(bytes, output);
                    } finally {
                        IOUtils.closeQuietly(output);
                    }
                    taskTransaction.info(String.format("Downloaded %s", entry.getName(), entry.getSize()));
                    makeExecutable(dstFile);
                }
            }
        } finally {
            IOUtils.closeQuietly(zipInput);
        }
    }

    public void cancel(TaskTransaction taskTransaction) throws ExecuteException, IOException {
        long txId = taskTransaction.getId();
        String eventType = taskTransaction.getMeta().getEventType();

        CommandLine cmdLine = new CommandLine("bash");
        cmdLine.addArgument(this.baseDir + "/shell/cancel.sh");
        cmdLine.addArgument(this.baseDir);
        cmdLine.addArgument(String.valueOf(txId));
        cmdLine.addArgument(eventType);
        DefaultExecutor executor = new DefaultExecutor();
        executor.setExitValues(new int[] { 0 });

        executor.execute(cmdLine);
    }

    private void runShell(final TaskTransaction taskTransaction, long txId, String command, String eventType,
                          String attachmentDir) throws ExecuteException, IOException {
        CommandLine cmdLine = new CommandLine("bash");
        cmdLine.addArgument(this.baseDir + "/shell/run.sh");
        cmdLine.addArgument(this.baseDir);
        cmdLine.addArgument(String.valueOf(txId));
        cmdLine.addArgument(eventType);
        cmdLine.addArgument(command, false);
        if (attachmentDir != null) {
            cmdLine.addArgument(attachmentDir);
        }
        DefaultExecutor executor = new DefaultExecutor();
        executor.setExitValues(null);

        executor.execute(cmdLine);
    }

    private boolean everStarted(long txId, String eventType) {
        // 是否有pid
        File file = new File(this.baseDir + "/" + txId + "/" + eventType + "/pid");
        return file.exists();
    }

    private Integer getExitCode(long txId, String eventType) {
        File file = new File(this.baseDir + "/" + txId + "/" + eventType + "/exitcode");
        if (file.exists()) {
            FileInputStream fileInputStream = null;
            try {
                fileInputStream = new FileInputStream(file);
                String exitCodeStr = StringUtils.trim(IOUtils.toString(fileInputStream));
                return Integer.parseInt(exitCodeStr);
            } catch (Exception e) {
                return null;
            } finally {
                IOUtils.closeQuietly(fileInputStream);
            }
        }
        return null;
    }

    private boolean checkRunningByPid(long txId, String eventType) throws ExecuteException, IOException {
        CommandLine cmdLine = new CommandLine("bash");
        cmdLine.addArgument(this.baseDir + "/shell/check.sh");
        cmdLine.addArgument(this.baseDir);
        cmdLine.addArgument(String.valueOf(txId));
        cmdLine.addArgument(eventType);
        DefaultExecutor executor = new DefaultExecutor();
        executor.setExitValues(null);

        int exitCode = executor.execute(cmdLine);

        return exitCode == 1;
    }

    public void setAttachmentRootDir(String attachmentDir) {
        this.attachmentRootDir = attachmentDir;
    }

}
